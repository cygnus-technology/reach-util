C code refactoring stuff
	JSON conversion, get JSON spec ready for Enovation
		Challenge key access level handling
	Switch to JSON files
	
	Declare stuff as const
	No more global variables
		How to handle this?
			Demos can't modify parameter descriptions on the fly
			File sizes are const, but provide an array of current sizes for each file
			
			How to make enum/bitfield/bool descriptions easy for the application to use?
				arrays of cr_ParamExKeys + structs which have ID, type, # of enums, and pointer to array
				Slightly more complicated code for grabbing the descriptions, but then overall an improvement I think
				How to access these from the application?
					Typical usage would be to get a string from a value
					char * app_get_???_label(param_ex_id_t, uint32_t value)
						return 0 if no matching label
			how to access parameter values manually?
				cr_ParameterValue * app_get_parameter(param_t pid);
				Writing a parameter should always involve updating the timestamp as well
				EDIT: nope, this seems far too limiting
				keep parameter table global
				file sizes should also be global in case someone wants to use that directly with a continually-updating file
	
	Generate hashes in the script and have these available as defines
		all parameters + all descriptions
		all parameters
		RAM-only
		NVM-only
		individual types
	
	Access control
		enum for access levels
		Each access level has a name and a challenge key (mandatory, UI could have a button to auto-generate one but this needs to be documented somewhere other than the C code)
		Seems pretty reasonable to store this data in the access levels within the C code
	
	Should device name always be tied to advertised name?  I don't think so
	
	Optional support for single-block NVM storage?  Not sure this is good enough of an implementation to warrant it.


JSON changes
	Access levels
		Level definitions:
			Each element has fields for name, challenge key, and an optional list of sub-elements 
		Possible use cases:
			General concept: could either interpret this as limiting features or expanding features
			How to handle a single parameter:
				Specify a level it's accessable under
				Can also be accessed by any sub-layer of this
		C representation: bitfields
			111111111111111111111111
			000000000011111111111100
			000000000000000011111000
			000000000000000000110000
			
			if (CURRENT_MASK & ACCESS_LEVEL_REQUIRED)
				show
			Basic 4-layer system
				No key:      1111
				Limited key: 0111
				Dev key:     0011
				Full key:    0001
			
			if limited to 64-bit integers, what's the actual limit to the number of challenge keys?
				single layer: 64
				branching tree:
				111111
				11100
				00111
				01000
				00100
				000010
				000001
				= 4 + 2 + 1 for 6 bits
			How to handle this with definitions?
				LEVEL_A = 0b100 | LEVEL_A_A | LEVEL_A_B
	Default notifications for parameters
NOTE: not supporting access levels dynamically controlling read/write access for parameters and files yet, this is another can of worms


Code generator structure:
	Make a separate generated folder for everything
		parameter_repository.c/.h
			.h:
				cr_gen_param_id_t
				cr_gen_param_idx_t
				cr_gen_param_ex_id_t
				cr_gen_param_ex_idx_t
				cr_gen_parameter_values[]
				
		files.c/.h
		commands.c/.h
		cli.c/.h

Existing dict structure:
	Device info:
		Device Name
		Manufacturer
		Device Description
		CLI Supported
		Time Supported
		Application Identifier
		Endpoints
	Parameters:
		Name
		Type
		Extended Type
		Description
		Units
		Size
		Access
		Minimum Value
		Default Value
		Maximum Value
		Storage Location
		Notify
		Min Period
		Max Period
		Delta

Refactoring tasks:
	gen_enum still fine technically, but enums/values should be refactored to a list of dicts with optional value fields, should also be smart about whether values need to be called out explicitly or not
	should have gen_struct_instance(contents (dict with field:value))
	CrDeviceInfo:
		init:
			Not many changes except services
		add_supported_device:
			not needed
		as c reach struct
			similar
	
	CrParamExInfo:
		No longer needs the list of parameters used by it
		Should have a class variable for the ID number
		Keep track of data types as a variable rather than 3 different classes
		init:
			different fields depending on type
		add param:
		
		as c enum:
		
		as c reach struct:
	
	CrParameterInfo:
		Class variable thing for ID numbers, now need to store a real ID
		Look up extended types, make sure it exists, store name for accessing the labels later
	
	Files:
		
Wait maybe this whole system is different
	Additional validation required:
		Make sure labels referenced by parameters actually exist
		Eventually need to do some validation with certain fields only being required if certain features are enabled, probably within scope of schema
		Make sure IDs don't conflict
		Make sure names are unique
			Eventually, this shouldn't be a requirement, just need to be smarter about enum names
		Assign numbers to bitfields and enumerations when they weren't explicitly defined
		Assign file and parameter ID numbers as needed, this is where we can see if they conflict
	Once we have this, we know the json is a perfectly valid description of the entire system

General functions needed:
	gen_enum (special support for bitfields?)
	gen_c_array(multi-dimensional array, just raw text for each field)
	gen_protobuf(array of expected fields (mark optional ones), array of provided fields)
	
	.h file stuff:
		INCLUDE_<service>_SERVICE
		NUM_<things>
		eventually, hashes (could also theoretically calculate a hash of the JSON, but it'd be much better to do the real C hash)
			Maybe keep the hash function in its own file and dynamically calculate this by compiling some C code and running it?
			Probably need to add GCC as a requirement to do this
			Add a feature for dynamic/static hashes
		
		cr_gen_param_t
		cr_gen_{enum name}_t
		cr_gen_{bitfield name}_idx_t
		cr_gen_{bitfield name}_t
		
		global variables as needed:
			parameter values
			file descriptions
	
	.c file stuff:
		device info
		parameter values
		parameter descriptions
			IDs need to be from enums

C file contents required:
	Device Info
		global function declarations: di_global_function_declarations.h
		global functions: di_global_functions.c
		static function declarations: di_static_function_declarations.c
		static functions: di_static_functions.c
		weak function definitions: di_weak_function_declarations.h
		weak functions: di_weak_functions.c
	Parameter Repository
		pr_<names>
		prex_<names>
		Separate file just for the hash function?
	Files
		files_<names>
	Commands
		cmds_<names>
	CLI
		cli_<names>


python <name>.py -d/--definition <definition file> -s/--source <source location> -i/--include <include location> -<insert letter>/--<insert description> <custom code folder tree location (top folder)> --spaces 4 --tabs 1




Class structure:
	ReachDevice
		Parameter
			convert to enum name and value
			convert to protobuf message struct
		ParameterLabel
			convert to enum name and value
			convert to label array
			convert to protobuf-esque struct
		File
			convert to enum name and value
			convert to protobuf message struct
		Command
			convert to enum name and value
			convert to protobuf message struct
		CliCommand
			convert to help line
			convert to handler
			convert to weak function declaration
		convert to C file
		convert to H file



static const cr_ParamExKey __cr_gen_<name>_labels = {
	{<id>, "label"},
};

typedef struct {
    uint32_t pei_id;
    uint8_t data_type;
    uint8_t num_labels;
    const cr_ParamExKey *labels;
} cr_gen_param_ex_t;


sample:
static const cr_gen_param_ex_t testB =
{
    .pei_id = 0,
    .data_type = 1,
    .num_labels = 2,
    .labels = testA
};
		
int temp[] =
{
	{1, 2, 3, 4},
	{
		.x = a,
		.y = b,
		.z = c
	},
	1
}




from Python.Services.ParameterRepository import Parameter
from Python.Services.ParameterRepository import ParamRepoService

# class ReachDevice:
#
#         # class Label:
#         #     def to_label_array(self, label: json):
#         #     def to_struct(self, label: json):
#     #
#     # class File:
#     #     def to_protobuf(self, file: json):
#     # class Command:
#     #     def to_protobuf(self, cmd: json):
#     # class CliCommand:
#     #     def to_help_code(self, cmd: json):
#     #     def to_handler(self, cmd: json):
#     #     def to_weak_function_declaration(self, cmd: json):

# for json_desc in device_description['services']['parameterRepositoryService']['parameters']:
#     param_desc = Parameter.to_protobuf(json_desc)
#     param_desc[-1] += ","
#     for line in param_desc:
#         print(line)

# param_desc = Parameter.to_protobuf(device_description['services']['parameterRepositoryService']['parameters'][2])
# for line in param_desc:
#     print(line)

test = ParamRepoService.gen_definitions(device_description['services']['parameterRepositoryService'])
for line in test:
    print(line)
print("")
test = ParamRepoService.gen_enums(device_description['services']['parameterRepositoryService'])
for enum in test:
    for line in enum:
        print(line)
    print("")

# for json_desc in device_description['services']['parameterRepositoryService']['extendedLabels']:
#     param_desc = ParamExInfo.to_local_array(json_desc)
#     for line in param_desc:
#         print(line)
#
#     param_desc = ParamExInfo.to_struct(json_desc)
#     for line in param_desc:
#         print(line)

# device = ReachDevice(device_description, indent="    ")
#
# # test_struct = device.Parameter.to_protobuf(device_description['services']['parameterRepositoryService']['parameters'][2])
# # for line in test_struct:
# #     print(line)
#
# a = [0, "TEST_ENUM", 2, 3]
# test_array = util.gen_c_array(a)
# test_array_2 = util.gen_c_array([test_array, test_array, test_array])
# for line in test_array_2:
#     print(line)
#
# #
# #
# # test_fields = ["a", "b", "c", "d", "e"]
# # test_values = [1, "\"Test\"", test_array, test_array_2, 7.3]
# #
# # test_struct_def = [
# #     {"field": "a", "value": 1, "optional": True},
# #     {"field": "b", "value": "\"Test\""},
# #     {"field": "c", "value": test_array},
# #     {"field": "d", "value": test_array_2},
# #     {"field": "e", "value": True},
# # ]
# #
# # test_struct = device.gen_protobuf_struct(test_struct_def)
# # for line in test_struct:
# #     print(line)
		
		
				
	