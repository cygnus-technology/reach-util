import sys
import argparse
import json
from pathlib import Path

from i3cgen.utils import util
from i3cgen.Validator import DeviceDescriptionValidator
from i3cgen.Services.ParameterRepository import ParamRepoService
from i3cgen.Services.FileService import FileService
from i3cgen.Services.CommandService import CommandService

# Use a raw string to get formatting to print correctly
header_string = r'''/********************************************************************************************
 *    _ ____  ___             _         _     ___              _                        _
 *   (_)__ / | _ \_ _ ___  __| |_  _ __| |_  |   \ _____ _____| |___ _ __ _ __  ___ _ _| |_
 *   | ||_ \ |  _/ '_/ _ \/ _` | || / _|  _| | |) / -_) V / -_) / _ \ '_ \ '  \/ -_) ' \  _|
 *   |_|___/ |_| |_| \___/\__,_|\_,_\__|\__| |___/\___|\_/\___|_\___/ .__/_|_|_\___|_||_\__|
 *                                                                  |_|
 *                           -----------------------------------
 *                          Copyright i3 Product Development 2024
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * @file      definitions.h/.c
 * @brief     A minimal implementation of Reach data access.  Auto-generated by a Python script.
 * @copyright 2023-2024 i3 Product Development. All Rights Reserved.
 *
 * Original Author: Chuck Peplinski
 * Script Author: Joseph Peplinski
 * Script Author: Andrew Carlson
 *
 ********************************************************************************************/

'''

def main() -> int:
    parser = argparse.ArgumentParser(description='A script to transform a specification file defining a Reach device into C code')
    parser.add_argument('-d', '--definition', help="The .json file to parse", required=True)
    parser.add_argument('-s', '--source-location', help="Where to put the generated 'definitions.c' file", default=".", type=Path)
    parser.add_argument('-i', '--include-location', help="Where to put the generated 'definitions.h' file", default=".", type=Path)
    group = parser.add_mutually_exclusive_group()
    group.add_argument('--spaces', help="How many spaces to use for indent levels", type=int, default=4)
    group.add_argument('--tabs', help="How many tabs to use for indent levels", type=int)

    args = parser.parse_args()

    if args.tabs:
        util.init('\t' * args.tabs)
    else:
        util.init(' ' * args.spaces)

    # Validate the definition, source, and header paths
    if not Path(args.definition).exists():
        print(f'-d {args.definition} not found, exiting...')
        return -1

    if not args.include_location.exists():
        print(f'{args.include_location} not found, creating...')
        Path.mkdir(args.include_location)
    include_path = args.include_location

    if not args.source_location.exists():
        print(f'{args.source_location} not found, creating...')
        Path.mkdir(args.source_location)
    source_path = args.source_location

    # Create the schema validator, this can be reused
    # This assumes the scheams directory is relative to new-gen.py
    schema_dir = Path(__file__).parent.resolve()
    schema_dir = schema_dir.joinpath('schemas')
    validator = DeviceDescriptionValidator(schema_dir)

    # Load the file, this could potentially have JSON format errors
    with open(args.definition, "r") as f:
        print("Processing description file")
        device_description = json.load(f)

    # Do additional validation
    try:
        device_description = validator.validate(device_description)
        print("Input file validated successfully.")
    except Exception as e:
        print(e)


    print("Generating Defines and Enums...")
    define_groups = []
    enum_groups = []
    values_groups = []
    ########################
    # Parameter Repo Service
    ########################
    if 'parameterRepositoryService' in device_description['services']:
        gen_defines = ParamRepoService.gen_definitions(device_description['services']['parameterRepositoryService'])
        define_groups.append(gen_defines)
        gen_enums = ParamRepoService.gen_enums(device_description['services']['parameterRepositoryService'])
        enum_groups.append(gen_enums)
        gen_values = ParamRepoService.gen_variables(device_description['services']['parameterRepositoryService'])
        values_groups.append(gen_values)

    ##############
    # File Service
    ##############
    if 'fileService' in device_description['services']:
        gen_defines = FileService.gen_definitions(device_description['services']['fileService'])
        define_groups.append(gen_defines)
        gen_enums = FileService.gen_enums(device_description['services']['fileService'])
        enum_groups.append(gen_enums)
        gen_values = FileService.gen_variables(device_description['services']['fileService'])
        values_groups.append(gen_values)

    ##############
    # Command Service
    ##############
    if 'commandService' in device_description['services']:
        gen_defines = CommandService.gen_definitions(device_description['services']['commandService'])
        define_groups.append(gen_defines)
        gen_enums = CommandService.gen_enums(device_description['services']['commandService'])
        enum_groups.append(gen_enums)
        gen_values = CommandService.gen_variables(device_description['services']['commandService'])
        values_groups.append(gen_values)

    print("Writing source/header files")
    with open(include_path.joinpath('definitions.h'), "+w") as f:
        f.write(header_string)
        f.write('#ifndef __DEFINITIONS_H__\n')
        f.write('#define __DEFINITIONS_H__\n')
        f.write('\n')

        for define_group in define_groups:
            for line in define_group:
                f.write(f'{line}\n')
        f.write('\n')

        for enum_group in enum_groups:
            for enum in enum_group:
                for line in enum:
                    f.write(f'{line}\n')
                f.write('\n')

        f.write('#endif /* __DEFINITIONS_H__ */\n')

    with open(source_path.joinpath('definitions.c'), '+w') as f:
        f.write(header_string)
        f.write('#include \"definitions.h\"\n')
        f.write('\n')

        for value_group in values_groups:
            for value in value_group:
                for line in value:
                    f.write(f'{line}\n')
        f.write('\n')

    return 0

if __name__ == '__main__':
    sys.exit(main())